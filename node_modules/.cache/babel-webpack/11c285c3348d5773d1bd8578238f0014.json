{"ast":null,"code":"import _asyncToGenerator from \"/Users/watcharapun/Documents/development-[DEV]/stream-ipcam/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport './flags_wasm';\nimport { DataStorage, deprecationWarn, engine, env, KernelBackend, util } from '@tensorflow/tfjs-core';\nimport wasmFactoryThreadedSimd from '../wasm-out/tfjs-backend-wasm-threaded-simd.js'; // @ts-ignore\n\nimport { wasmWorkerContents } from '../wasm-out/tfjs-backend-wasm-threaded-simd.worker.js';\nimport wasmFactory from '../wasm-out/tfjs-backend-wasm.js';\nexport class BackendWasm extends KernelBackend {\n  constructor(wasm) {\n    super();\n    this.wasm = wasm; // 0 is reserved for null data ids.\n\n    this.dataIdNextNumber = 1;\n    this.wasm.tfjs.init();\n    this.dataIdMap = new DataStorage(this, engine());\n  }\n\n  write(values, shape, dtype) {\n    const dataId = {\n      id: this.dataIdNextNumber++\n    };\n    this.move(dataId, values, shape, dtype, 1);\n    return dataId;\n  }\n\n  numDataIds() {\n    return this.dataIdMap.numDataIds();\n  }\n\n  time(f) {\n    return _asyncToGenerator(function* () {\n      const start = util.now();\n      f();\n      const kernelMs = util.now() - start;\n      return {\n        kernelMs\n      };\n    })();\n  }\n\n  move(dataId, values, shape, dtype, refCount) {\n    const id = this.dataIdNextNumber++;\n\n    if (dtype === 'string') {\n      const stringBytes = values;\n      this.dataIdMap.set(dataId, {\n        id,\n        stringBytes,\n        shape,\n        dtype,\n        memoryOffset: null,\n        refCount\n      });\n      return;\n    }\n\n    const size = util.sizeFromShape(shape);\n    const numBytes = size * util.bytesPerElement(dtype);\n\n    const memoryOffset = this.wasm._malloc(numBytes);\n\n    this.dataIdMap.set(dataId, {\n      id,\n      memoryOffset,\n      shape,\n      dtype,\n      refCount\n    });\n    this.wasm.tfjs.registerTensor(id, size, memoryOffset);\n\n    if (values != null) {\n      this.wasm.HEAPU8.set(new Uint8Array(values.buffer, values.byteOffset, numBytes), memoryOffset);\n    }\n  }\n\n  read(dataId) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      return _this.readSync(dataId);\n    })();\n  }\n\n  readSync(dataId) {\n    const {\n      memoryOffset,\n      dtype,\n      shape,\n      stringBytes\n    } = this.dataIdMap.get(dataId);\n\n    if (dtype === 'string') {\n      return stringBytes;\n    }\n\n    const bytes = this.wasm.HEAPU8.slice(memoryOffset, memoryOffset + util.sizeFromShape(shape) * util.bytesPerElement(dtype));\n    return typedArrayFromBuffer(bytes.buffer, dtype);\n  }\n  /**\n   * Dispose the memory if the dataId has 0 refCount. Return true if the memory\n   * is released, false otherwise.\n   * @param dataId\n   * @oaram force Optional, remove the data regardless of refCount\n   */\n\n\n  disposeData(dataId, force = false) {\n    if (this.dataIdMap.has(dataId)) {\n      const data = this.dataIdMap.get(dataId);\n      data.refCount--;\n\n      if (!force && data.refCount > 0) {\n        return false;\n      }\n\n      this.wasm._free(data.memoryOffset);\n\n      this.wasm.tfjs.disposeData(data.id);\n      this.dataIdMap.delete(dataId);\n    }\n\n    return true;\n  }\n  /** Return refCount of a `TensorData`. */\n\n\n  refCount(dataId) {\n    if (this.dataIdMap.has(dataId)) {\n      const tensorData = this.dataIdMap.get(dataId);\n      return tensorData.refCount;\n    }\n\n    return 0;\n  }\n\n  incRef(dataId) {\n    const data = this.dataIdMap.get(dataId);\n\n    if (data != null) {\n      data.refCount++;\n    }\n  }\n\n  floatPrecision() {\n    return 32;\n  } // Returns the memory offset of a tensor. Useful for debugging and unit\n  // testing.\n\n\n  getMemoryOffset(dataId) {\n    return this.dataIdMap.get(dataId).memoryOffset;\n  }\n\n  dispose() {\n    this.wasm.tfjs.dispose();\n\n    if ('PThread' in this.wasm) {\n      this.wasm.PThread.terminateAllThreads();\n    }\n\n    this.wasm = null;\n  }\n\n  memory() {\n    return {\n      unreliable: false\n    };\n  }\n  /**\n   * Make a tensor info for the output of an op. If `memoryOffset` is not\n   * present, this method allocates memory on the WASM heap. If `memoryOffset`\n   * is present, the memory was allocated elsewhere (in c++) and we just record\n   * the pointer where that memory lives.\n   */\n\n\n  makeOutput(shape, dtype, memoryOffset) {\n    let dataId;\n\n    if (memoryOffset == null) {\n      dataId = this.write(null\n      /* values */\n      , shape, dtype);\n    } else {\n      const id = this.dataIdNextNumber++;\n      dataId = {\n        id\n      };\n      this.dataIdMap.set(dataId, {\n        id,\n        memoryOffset,\n        shape,\n        dtype,\n        refCount: 1\n      });\n      const size = util.sizeFromShape(shape);\n      this.wasm.tfjs.registerTensor(id, size, memoryOffset);\n    }\n\n    return {\n      dataId,\n      shape,\n      dtype\n    };\n  }\n\n  typedArrayFromHeap({\n    shape,\n    dtype,\n    dataId\n  }) {\n    const buffer = this.wasm.HEAPU8.buffer;\n    const {\n      memoryOffset\n    } = this.dataIdMap.get(dataId);\n    const size = util.sizeFromShape(shape);\n\n    switch (dtype) {\n      case 'float32':\n        return new Float32Array(buffer, memoryOffset, size);\n\n      case 'int32':\n        return new Int32Array(buffer, memoryOffset, size);\n\n      case 'bool':\n        return new Uint8Array(buffer, memoryOffset, size);\n\n      default:\n        throw new Error(`Unknown dtype ${dtype}`);\n    }\n  }\n\n}\n\nfunction createInstantiateWasmFunc(path) {\n  // this will be replace by rollup plugin patchWechatWebAssembly in \n  // minprogram's output.\n  // tslint:disable-next-line:no-any\n  return (imports, callback) => {\n    util.fetch(path, {\n      credentials: 'same-origin'\n    }).then(response => {\n      if (!response['ok']) {\n        imports.env.a(`failed to load wasm binary file at '${path}'`);\n      }\n\n      response.arrayBuffer().then(binary => {\n        WebAssembly.instantiate(binary, imports).then(output => {\n          callback(output.instance, output.module);\n        });\n      });\n    });\n    return {};\n  };\n}\n/**\n * Returns the path of the WASM binary.\n * @param simdSupported whether SIMD is supported\n * @param threadsSupported whether multithreading is supported\n * @param wasmModuleFolder the directory containing the WASM binaries.\n */\n\n\nfunction getPathToWasmBinary(simdSupported, threadsSupported, wasmModuleFolder) {\n  if (wasmPath != null) {\n    // If wasmPath is defined, the user has supplied a full path to\n    // the vanilla .wasm binary.\n    return wasmPath;\n  }\n\n  let path = 'tfjs-backend-wasm.wasm';\n\n  if (simdSupported && threadsSupported) {\n    path = 'tfjs-backend-wasm-threaded-simd.wasm';\n  } else if (simdSupported) {\n    path = 'tfjs-backend-wasm-simd.wasm';\n  }\n\n  if (wasmFileMap != null) {\n    if (wasmFileMap[path] != null) {\n      return wasmFileMap[path];\n    }\n  }\n\n  return wasmModuleFolder + path;\n}\n/**\n * Initializes the wasm module and creates the js <--> wasm bridge.\n *\n * NOTE: We wrap the wasm module in a object with property 'wasm' instead of\n * returning Promise<BackendWasmModule> to avoid freezing Chrome (last tested\n * in Chrome 76).\n */\n\n\nexport function init() {\n  return _init.apply(this, arguments);\n}\n\nfunction _init() {\n  _init = _asyncToGenerator(function* () {\n    const [simdSupported, threadsSupported] = yield Promise.all([env().getAsync('WASM_HAS_SIMD_SUPPORT'), env().getAsync('WASM_HAS_MULTITHREAD_SUPPORT')]);\n    return new Promise((resolve, reject) => {\n      const factoryConfig = {};\n      /**\n       * This function overrides the Emscripten module locateFile utility.\n       * @param path The relative path to the file that needs to be loaded.\n       * @param prefix The path to the main JavaScript file's directory.\n       */\n\n      factoryConfig.locateFile = (path, prefix) => {\n        if (path.endsWith('.worker.js')) {\n          const response = wasmWorkerContents;\n          const blob = new Blob([response], {\n            type: 'application/javascript'\n          });\n          return URL.createObjectURL(blob);\n        }\n\n        if (path.endsWith('.wasm')) {\n          return getPathToWasmBinary(simdSupported, threadsSupported, wasmPathPrefix != null ? wasmPathPrefix : prefix);\n        }\n\n        return prefix + path;\n      }; // Use the instantiateWasm override when system fetch is not available.\n      // Reference:\n      // https://github.com/emscripten-core/emscripten/blob/2bca083cbbd5a4133db61fbd74d04f7feecfa907/tests/manual_wasm_instantiate.html#L170\n\n\n      if (customFetch) {\n        factoryConfig.instantiateWasm = createInstantiateWasmFunc(getPathToWasmBinary(simdSupported, threadsSupported, wasmPathPrefix != null ? wasmPathPrefix : ''));\n      }\n\n      let initialized = false;\n\n      factoryConfig.onAbort = () => {\n        if (initialized) {\n          // Emscripten already called console.warn so no need to double log.\n          return;\n        }\n\n        if (initAborted) {\n          // Emscripten calls `onAbort` twice, resulting in double error\n          // messages.\n          return;\n        }\n\n        initAborted = true;\n        const rejectMsg = 'Make sure the server can serve the `.wasm` file relative to the ' + 'bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers';\n        reject({\n          message: rejectMsg\n        });\n      };\n\n      let wasm; // If `wasmPath` has been defined we must initialize the vanilla module.\n\n      if (threadsSupported && simdSupported && wasmPath == null) {\n        factoryConfig.mainScriptUrlOrBlob = new Blob([`var WasmBackendModuleThreadedSimd = ` + wasmFactoryThreadedSimd.toString()], {\n          type: 'text/javascript'\n        });\n        wasm = wasmFactoryThreadedSimd(factoryConfig);\n      } else {\n        // The wasmFactory works for both vanilla and SIMD binaries.\n        wasm = wasmFactory(factoryConfig);\n      } // The WASM module has been successfully created by the factory.\n      // Any error will be caught by the onAbort callback defined above.\n\n\n      wasm.then(module => {\n        initialized = true;\n        initAborted = false;\n        const voidReturnType = null; // Using the tfjs namespace to avoid conflict with emscripten's API.\n\n        module.tfjs = {\n          init: module.cwrap('init', null, []),\n          registerTensor: module.cwrap('register_tensor', null, ['number', 'number', 'number']),\n          disposeData: module.cwrap('dispose_data', voidReturnType, ['number']),\n          dispose: module.cwrap('dispose', voidReturnType, [])\n        };\n        resolve({\n          wasm: module\n        });\n      });\n    });\n  });\n  return _init.apply(this, arguments);\n}\n\nfunction typedArrayFromBuffer(buffer, dtype) {\n  switch (dtype) {\n    case 'float32':\n      return new Float32Array(buffer);\n\n    case 'int32':\n      return new Int32Array(buffer);\n\n    case 'bool':\n      return new Uint8Array(buffer);\n\n    default:\n      throw new Error(`Unknown dtype ${dtype}`);\n  }\n}\n\nconst wasmBinaryNames = ['tfjs-backend-wasm.wasm', 'tfjs-backend-wasm-simd.wasm', 'tfjs-backend-wasm-threaded-simd.wasm'];\nlet wasmPath = null;\nlet wasmPathPrefix = null;\nlet wasmFileMap = {};\nlet initAborted = false;\nlet customFetch = false;\n/**\n * @deprecated Use `setWasmPaths` instead.\n * Sets the path to the `.wasm` file which will be fetched when the wasm\n * backend is initialized. See\n * https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers\n * for more details.\n * @param path wasm file path or url\n * @param usePlatformFetch optional boolean to use platform fetch to download\n *     the wasm file, default to false.\n *\n * @doc {heading: 'Environment', namespace: 'wasm'}\n */\n\nexport function setWasmPath(path, usePlatformFetch = false) {\n  deprecationWarn('setWasmPath has been deprecated in favor of setWasmPaths and' + ' will be removed in a future release.');\n\n  if (initAborted) {\n    throw new Error('The WASM backend was already initialized. Make sure you call ' + '`setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`');\n  }\n\n  wasmPath = path;\n  customFetch = usePlatformFetch;\n}\n/**\n * Configures the locations of the WASM binaries.\n *\n * ```js\n * setWasmPaths({\n *  'tfjs-backend-wasm.wasm': 'renamed.wasm',\n *  'tfjs-backend-wasm-simd.wasm': 'renamed-simd.wasm',\n *  'tfjs-backend-wasm-threaded-simd.wasm': 'renamed-threaded-simd.wasm'\n * });\n * tf.setBackend('wasm');\n * ```\n *\n * @param prefixOrFileMap This can be either a string or object:\n *  - (string) The path to the directory where the WASM binaries are located.\n *     Note that this prefix will be used to load each binary (vanilla,\n *     SIMD-enabled, threading-enabled, etc.).\n *  - (object) Mapping from names of WASM binaries to custom\n *     full paths specifying the locations of those binaries. This is useful if\n *     your WASM binaries are not all located in the same directory, or if your\n *     WASM binaries have been renamed.\n * @param usePlatformFetch optional boolean to use platform fetch to download\n *     the wasm file, default to false.\n *\n * @doc {heading: 'Environment', namespace: 'wasm'}\n */\n\nexport function setWasmPaths(prefixOrFileMap, usePlatformFetch = false) {\n  if (initAborted) {\n    throw new Error('The WASM backend was already initialized. Make sure you call ' + '`setWasmPaths()` before you call `tf.setBackend()` or ' + '`tf.ready()`');\n  }\n\n  if (typeof prefixOrFileMap === 'string') {\n    wasmPathPrefix = prefixOrFileMap;\n  } else {\n    wasmFileMap = prefixOrFileMap;\n    const missingPaths = wasmBinaryNames.filter(name => wasmFileMap[name] == null);\n\n    if (missingPaths.length > 0) {\n      throw new Error(`There were no entries found for the following binaries: ` + `${missingPaths.join(',')}. Please either call setWasmPaths with a ` + `map providing a path for each binary, or with a string indicating ` + `the directory where all the binaries can be found.`);\n    }\n  }\n\n  customFetch = usePlatformFetch;\n}\n/** Used in unit tests. */\n\nexport function resetWasmPath() {\n  wasmPath = null;\n  wasmPathPrefix = null;\n  wasmFileMap = {};\n  customFetch = false;\n  initAborted = false;\n} //# sourceMappingURL=backend_wasm.js.map","map":{"version":3,"sources":["/Users/watcharapun/Documents/development-[DEV]/stream-ipcam/node_modules/@tensorflow/tfjs-backend-wasm/dist/backend_wasm.js"],"names":["DataStorage","deprecationWarn","engine","env","KernelBackend","util","wasmFactoryThreadedSimd","wasmWorkerContents","wasmFactory","BackendWasm","constructor","wasm","dataIdNextNumber","tfjs","init","dataIdMap","write","values","shape","dtype","dataId","id","move","numDataIds","time","f","start","now","kernelMs","refCount","stringBytes","set","memoryOffset","size","sizeFromShape","numBytes","bytesPerElement","_malloc","registerTensor","HEAPU8","Uint8Array","buffer","byteOffset","read","readSync","get","bytes","slice","typedArrayFromBuffer","disposeData","force","has","data","_free","delete","tensorData","incRef","floatPrecision","getMemoryOffset","dispose","PThread","terminateAllThreads","memory","unreliable","makeOutput","typedArrayFromHeap","Float32Array","Int32Array","Error","createInstantiateWasmFunc","path","imports","callback","fetch","credentials","then","response","a","arrayBuffer","binary","WebAssembly","instantiate","output","instance","module","getPathToWasmBinary","simdSupported","threadsSupported","wasmModuleFolder","wasmPath","wasmFileMap","Promise","all","getAsync","resolve","reject","factoryConfig","locateFile","prefix","endsWith","blob","Blob","type","URL","createObjectURL","wasmPathPrefix","customFetch","instantiateWasm","initialized","onAbort","initAborted","rejectMsg","message","mainScriptUrlOrBlob","toString","voidReturnType","cwrap","wasmBinaryNames","setWasmPath","usePlatformFetch","setWasmPaths","prefixOrFileMap","missingPaths","filter","name","length","join","resetWasmPath"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport './flags_wasm';\nimport { DataStorage, deprecationWarn, engine, env, KernelBackend, util } from '@tensorflow/tfjs-core';\nimport wasmFactoryThreadedSimd from '../wasm-out/tfjs-backend-wasm-threaded-simd.js';\n// @ts-ignore\nimport { wasmWorkerContents } from '../wasm-out/tfjs-backend-wasm-threaded-simd.worker.js';\nimport wasmFactory from '../wasm-out/tfjs-backend-wasm.js';\nexport class BackendWasm extends KernelBackend {\n    constructor(wasm) {\n        super();\n        this.wasm = wasm;\n        // 0 is reserved for null data ids.\n        this.dataIdNextNumber = 1;\n        this.wasm.tfjs.init();\n        this.dataIdMap = new DataStorage(this, engine());\n    }\n    write(values, shape, dtype) {\n        const dataId = { id: this.dataIdNextNumber++ };\n        this.move(dataId, values, shape, dtype, 1);\n        return dataId;\n    }\n    numDataIds() {\n        return this.dataIdMap.numDataIds();\n    }\n    async time(f) {\n        const start = util.now();\n        f();\n        const kernelMs = util.now() - start;\n        return { kernelMs };\n    }\n    move(dataId, values, shape, dtype, refCount) {\n        const id = this.dataIdNextNumber++;\n        if (dtype === 'string') {\n            const stringBytes = values;\n            this.dataIdMap.set(dataId, { id, stringBytes, shape, dtype, memoryOffset: null, refCount });\n            return;\n        }\n        const size = util.sizeFromShape(shape);\n        const numBytes = size * util.bytesPerElement(dtype);\n        const memoryOffset = this.wasm._malloc(numBytes);\n        this.dataIdMap.set(dataId, { id, memoryOffset, shape, dtype, refCount });\n        this.wasm.tfjs.registerTensor(id, size, memoryOffset);\n        if (values != null) {\n            this.wasm.HEAPU8.set(new Uint8Array(values.buffer, values.byteOffset, numBytes), memoryOffset);\n        }\n    }\n    async read(dataId) {\n        return this.readSync(dataId);\n    }\n    readSync(dataId) {\n        const { memoryOffset, dtype, shape, stringBytes } = this.dataIdMap.get(dataId);\n        if (dtype === 'string') {\n            return stringBytes;\n        }\n        const bytes = this.wasm.HEAPU8.slice(memoryOffset, memoryOffset + util.sizeFromShape(shape) * util.bytesPerElement(dtype));\n        return typedArrayFromBuffer(bytes.buffer, dtype);\n    }\n    /**\n     * Dispose the memory if the dataId has 0 refCount. Return true if the memory\n     * is released, false otherwise.\n     * @param dataId\n     * @oaram force Optional, remove the data regardless of refCount\n     */\n    disposeData(dataId, force = false) {\n        if (this.dataIdMap.has(dataId)) {\n            const data = this.dataIdMap.get(dataId);\n            data.refCount--;\n            if (!force && data.refCount > 0) {\n                return false;\n            }\n            this.wasm._free(data.memoryOffset);\n            this.wasm.tfjs.disposeData(data.id);\n            this.dataIdMap.delete(dataId);\n        }\n        return true;\n    }\n    /** Return refCount of a `TensorData`. */\n    refCount(dataId) {\n        if (this.dataIdMap.has(dataId)) {\n            const tensorData = this.dataIdMap.get(dataId);\n            return tensorData.refCount;\n        }\n        return 0;\n    }\n    incRef(dataId) {\n        const data = this.dataIdMap.get(dataId);\n        if (data != null) {\n            data.refCount++;\n        }\n    }\n    floatPrecision() {\n        return 32;\n    }\n    // Returns the memory offset of a tensor. Useful for debugging and unit\n    // testing.\n    getMemoryOffset(dataId) {\n        return this.dataIdMap.get(dataId).memoryOffset;\n    }\n    dispose() {\n        this.wasm.tfjs.dispose();\n        if ('PThread' in this.wasm) {\n            this.wasm.PThread.terminateAllThreads();\n        }\n        this.wasm = null;\n    }\n    memory() {\n        return { unreliable: false };\n    }\n    /**\n     * Make a tensor info for the output of an op. If `memoryOffset` is not\n     * present, this method allocates memory on the WASM heap. If `memoryOffset`\n     * is present, the memory was allocated elsewhere (in c++) and we just record\n     * the pointer where that memory lives.\n     */\n    makeOutput(shape, dtype, memoryOffset) {\n        let dataId;\n        if (memoryOffset == null) {\n            dataId = this.write(null /* values */, shape, dtype);\n        }\n        else {\n            const id = this.dataIdNextNumber++;\n            dataId = { id };\n            this.dataIdMap.set(dataId, { id, memoryOffset, shape, dtype, refCount: 1 });\n            const size = util.sizeFromShape(shape);\n            this.wasm.tfjs.registerTensor(id, size, memoryOffset);\n        }\n        return { dataId, shape, dtype };\n    }\n    typedArrayFromHeap({ shape, dtype, dataId }) {\n        const buffer = this.wasm.HEAPU8.buffer;\n        const { memoryOffset } = this.dataIdMap.get(dataId);\n        const size = util.sizeFromShape(shape);\n        switch (dtype) {\n            case 'float32':\n                return new Float32Array(buffer, memoryOffset, size);\n            case 'int32':\n                return new Int32Array(buffer, memoryOffset, size);\n            case 'bool':\n                return new Uint8Array(buffer, memoryOffset, size);\n            default:\n                throw new Error(`Unknown dtype ${dtype}`);\n        }\n    }\n}\nfunction createInstantiateWasmFunc(path) {\n    // this will be replace by rollup plugin patchWechatWebAssembly in \n    // minprogram's output.\n    // tslint:disable-next-line:no-any\n    return (imports, callback) => {\n        util.fetch(path, { credentials: 'same-origin' }).then((response) => {\n            if (!response['ok']) {\n                imports.env.a(`failed to load wasm binary file at '${path}'`);\n            }\n            response.arrayBuffer().then(binary => {\n                WebAssembly.instantiate(binary, imports).then(output => {\n                    callback(output.instance, output.module);\n                });\n            });\n        });\n        return {};\n    };\n}\n/**\n * Returns the path of the WASM binary.\n * @param simdSupported whether SIMD is supported\n * @param threadsSupported whether multithreading is supported\n * @param wasmModuleFolder the directory containing the WASM binaries.\n */\nfunction getPathToWasmBinary(simdSupported, threadsSupported, wasmModuleFolder) {\n    if (wasmPath != null) {\n        // If wasmPath is defined, the user has supplied a full path to\n        // the vanilla .wasm binary.\n        return wasmPath;\n    }\n    let path = 'tfjs-backend-wasm.wasm';\n    if (simdSupported && threadsSupported) {\n        path = 'tfjs-backend-wasm-threaded-simd.wasm';\n    }\n    else if (simdSupported) {\n        path = 'tfjs-backend-wasm-simd.wasm';\n    }\n    if (wasmFileMap != null) {\n        if (wasmFileMap[path] != null) {\n            return wasmFileMap[path];\n        }\n    }\n    return wasmModuleFolder + path;\n}\n/**\n * Initializes the wasm module and creates the js <--> wasm bridge.\n *\n * NOTE: We wrap the wasm module in a object with property 'wasm' instead of\n * returning Promise<BackendWasmModule> to avoid freezing Chrome (last tested\n * in Chrome 76).\n */\nexport async function init() {\n    const [simdSupported, threadsSupported] = await Promise.all([\n        env().getAsync('WASM_HAS_SIMD_SUPPORT'),\n        env().getAsync('WASM_HAS_MULTITHREAD_SUPPORT')\n    ]);\n    return new Promise((resolve, reject) => {\n        const factoryConfig = {};\n        /**\n         * This function overrides the Emscripten module locateFile utility.\n         * @param path The relative path to the file that needs to be loaded.\n         * @param prefix The path to the main JavaScript file's directory.\n         */\n        factoryConfig.locateFile = (path, prefix) => {\n            if (path.endsWith('.worker.js')) {\n                const response = wasmWorkerContents;\n                const blob = new Blob([response], { type: 'application/javascript' });\n                return URL.createObjectURL(blob);\n            }\n            if (path.endsWith('.wasm')) {\n                return getPathToWasmBinary(simdSupported, threadsSupported, wasmPathPrefix != null ? wasmPathPrefix : prefix);\n            }\n            return prefix + path;\n        };\n        // Use the instantiateWasm override when system fetch is not available.\n        // Reference:\n        // https://github.com/emscripten-core/emscripten/blob/2bca083cbbd5a4133db61fbd74d04f7feecfa907/tests/manual_wasm_instantiate.html#L170\n        if (customFetch) {\n            factoryConfig.instantiateWasm =\n                createInstantiateWasmFunc(getPathToWasmBinary(simdSupported, threadsSupported, wasmPathPrefix != null ? wasmPathPrefix : ''));\n        }\n        let initialized = false;\n        factoryConfig.onAbort = () => {\n            if (initialized) {\n                // Emscripten already called console.warn so no need to double log.\n                return;\n            }\n            if (initAborted) {\n                // Emscripten calls `onAbort` twice, resulting in double error\n                // messages.\n                return;\n            }\n            initAborted = true;\n            const rejectMsg = 'Make sure the server can serve the `.wasm` file relative to the ' +\n                'bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers';\n            reject({ message: rejectMsg });\n        };\n        let wasm;\n        // If `wasmPath` has been defined we must initialize the vanilla module.\n        if (threadsSupported && simdSupported && wasmPath == null) {\n            factoryConfig.mainScriptUrlOrBlob = new Blob([`var WasmBackendModuleThreadedSimd = ` +\n                    wasmFactoryThreadedSimd.toString()], { type: 'text/javascript' });\n            wasm = wasmFactoryThreadedSimd(factoryConfig);\n        }\n        else {\n            // The wasmFactory works for both vanilla and SIMD binaries.\n            wasm = wasmFactory(factoryConfig);\n        }\n        // The WASM module has been successfully created by the factory.\n        // Any error will be caught by the onAbort callback defined above.\n        wasm.then((module) => {\n            initialized = true;\n            initAborted = false;\n            const voidReturnType = null;\n            // Using the tfjs namespace to avoid conflict with emscripten's API.\n            module.tfjs = {\n                init: module.cwrap('init', null, []),\n                registerTensor: module.cwrap('register_tensor', null, [\n                    'number',\n                    'number',\n                    'number',\n                ]),\n                disposeData: module.cwrap('dispose_data', voidReturnType, ['number']),\n                dispose: module.cwrap('dispose', voidReturnType, []),\n            };\n            resolve({ wasm: module });\n        });\n    });\n}\nfunction typedArrayFromBuffer(buffer, dtype) {\n    switch (dtype) {\n        case 'float32':\n            return new Float32Array(buffer);\n        case 'int32':\n            return new Int32Array(buffer);\n        case 'bool':\n            return new Uint8Array(buffer);\n        default:\n            throw new Error(`Unknown dtype ${dtype}`);\n    }\n}\nconst wasmBinaryNames = [\n    'tfjs-backend-wasm.wasm', 'tfjs-backend-wasm-simd.wasm',\n    'tfjs-backend-wasm-threaded-simd.wasm'\n];\nlet wasmPath = null;\nlet wasmPathPrefix = null;\nlet wasmFileMap = {};\nlet initAborted = false;\nlet customFetch = false;\n/**\n * @deprecated Use `setWasmPaths` instead.\n * Sets the path to the `.wasm` file which will be fetched when the wasm\n * backend is initialized. See\n * https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers\n * for more details.\n * @param path wasm file path or url\n * @param usePlatformFetch optional boolean to use platform fetch to download\n *     the wasm file, default to false.\n *\n * @doc {heading: 'Environment', namespace: 'wasm'}\n */\nexport function setWasmPath(path, usePlatformFetch = false) {\n    deprecationWarn('setWasmPath has been deprecated in favor of setWasmPaths and' +\n        ' will be removed in a future release.');\n    if (initAborted) {\n        throw new Error('The WASM backend was already initialized. Make sure you call ' +\n            '`setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`');\n    }\n    wasmPath = path;\n    customFetch = usePlatformFetch;\n}\n/**\n * Configures the locations of the WASM binaries.\n *\n * ```js\n * setWasmPaths({\n *  'tfjs-backend-wasm.wasm': 'renamed.wasm',\n *  'tfjs-backend-wasm-simd.wasm': 'renamed-simd.wasm',\n *  'tfjs-backend-wasm-threaded-simd.wasm': 'renamed-threaded-simd.wasm'\n * });\n * tf.setBackend('wasm');\n * ```\n *\n * @param prefixOrFileMap This can be either a string or object:\n *  - (string) The path to the directory where the WASM binaries are located.\n *     Note that this prefix will be used to load each binary (vanilla,\n *     SIMD-enabled, threading-enabled, etc.).\n *  - (object) Mapping from names of WASM binaries to custom\n *     full paths specifying the locations of those binaries. This is useful if\n *     your WASM binaries are not all located in the same directory, or if your\n *     WASM binaries have been renamed.\n * @param usePlatformFetch optional boolean to use platform fetch to download\n *     the wasm file, default to false.\n *\n * @doc {heading: 'Environment', namespace: 'wasm'}\n */\nexport function setWasmPaths(prefixOrFileMap, usePlatformFetch = false) {\n    if (initAborted) {\n        throw new Error('The WASM backend was already initialized. Make sure you call ' +\n            '`setWasmPaths()` before you call `tf.setBackend()` or ' +\n            '`tf.ready()`');\n    }\n    if (typeof prefixOrFileMap === 'string') {\n        wasmPathPrefix = prefixOrFileMap;\n    }\n    else {\n        wasmFileMap = prefixOrFileMap;\n        const missingPaths = wasmBinaryNames.filter(name => wasmFileMap[name] == null);\n        if (missingPaths.length > 0) {\n            throw new Error(`There were no entries found for the following binaries: ` +\n                `${missingPaths.join(',')}. Please either call setWasmPaths with a ` +\n                `map providing a path for each binary, or with a string indicating ` +\n                `the directory where all the binaries can be found.`);\n        }\n    }\n    customFetch = usePlatformFetch;\n}\n/** Used in unit tests. */\nexport function resetWasmPath() {\n    wasmPath = null;\n    wasmPathPrefix = null;\n    wasmFileMap = {};\n    customFetch = false;\n    initAborted = false;\n}\n//# sourceMappingURL=backend_wasm.js.map"]},"metadata":{},"sourceType":"module"}